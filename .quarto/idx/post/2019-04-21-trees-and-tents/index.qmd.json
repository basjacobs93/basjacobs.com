{"title":"Trees and Tents","markdown":{"yaml":{"title":"Trees and Tents","author":"Bas","date":"2019-04-21"},"headingText":"Problem definition","containsRefs":false,"markdown":"\n\nTrees and Tents is a logic game in which tents need to be placed in a grid. Every tent must be next to a tree, and tents cannot touch horizontally, vertically or diagonally. For every row and column, the number of tents is given.\n\nThe website https://brainbashers.com/tents.asp posts a new puzzle every day, of which a 12x12 example is the following:\n\n![A 12x12 Trees and Tents puzzle from https://brainbashers.com/tents.asp](/post/2019-04-21-trees-and-tents/example.png){width=70%}\n\nIn this post, I will implement a solver for this puzzle in Julia using the [JuMP](https://github.com/JuliaOpt/JuMP.jl) package for mathematical optimization.\nThe complete code as a jupyter notebook can be found [here](https://github.com/basjacobs93/trees_and_tents).\n\n\nThe puzzle can be formulated as a linear programming problem. There are three types of constraints:\n\n - every tent must be next to a tree,\n - the number of tents for every row and column is given,\n - tents are not allowed to touch.\n\nEven though we treat this puzzle as an optimization problem, there is no objective to be maximized or minimized in this case; any placements of tents satisfying the constraints is a valid solution. This is similar to the [sudoku](https://github.com/JuliaOpt/JuMP.jl/blob/master/examples/sudoku.jl) [solutions](https://pythonhosted.org/PuLP/CaseStudies/a_sudoku_problem.html) in which the objective is also unimportant.\n\nJulia's JuMP package provides a clean interface to defining such a problem, and solving it with various solvers. In this case, we use [GLPK](https://www.gnu.org/software/glpk/) since it's free and works great for this problem. Solving the problem is a matter of writing down the constraints and calling `JuMP.optimize`.\n\n```julia\nusing JuMP, GLPK\n```\n\nAfter loading the necessary packages, we need to define the puzzle displayed above. In the website's html code, the puzzle is represented by three strings.\n\n - `lcpuzzle` is a string of numbers, denoting the cells from left to right, top to bottom. The values represent whether the corresponding cell is blank (0), or contains a tree (1) or a tent (2). Note that this string contains the solution to the problem as well, so this allows us to check the solution that JuMP found afterwards.\n - `lcrownumbers` is a string of numbers which denote the number of tents per row.\n - `lcrolnumbers` is a string of numbers which denote the number of tents per column.\n\n```julia\n# from html, 0=blank, 1=tree, 2=tent\nlcpuzzle = \"001202011200021001020012000120001200020100100000010200200000201000001212102020000000000010021012201000000200102002020102000001010001001201201212\"\nlcrownumbers = \"332123222404\"\nlccolnumbers = \"222322230505\"\n```\n\nWe rewrite the above representation into something that is more easy to work with:\n\n - `trees` is a list of `(i,j)` tuples corresponding to the locations of the trees.\n - `row_sums` and `col_sums` are lists of integers denoting the totals per row and column.\n - `n` is the size of the game, which is in this case 12.\n\n```julia\npuzzle = [parse(Int, i) for i in lcpuzzle]\nn = Int(sqrt(length(puzzle)))\n\ntrees = [(i, j) for i in 1:n, j in 1:n if puzzle[(i-1)*n + j] == 1]\nrow_sums = [parse(Int, i) for i in lcrownumbers]\ncol_sums = [parse(Int, i) for i in lccolnumbers]\n```\n\nWe initialize the solver, telling JuMP that we want to use GLPK. The variable that JuMP optimizes over is an $n\\times n$ matrix `x`, consisting of binary values, where a 0 means no tent for that cell, and a 1 means that the cell contains a tent.\n\n\n```julia\nmodel = Model(with_optimizer(GLPK.Optimizer))\n\n@variable(model, x[1:n, 1:n], Bin)\n```\n\n## Constraints\n\nWe are now ready to define the constraints. We start with the requirement that a tent be next to a tree.\n\nFirst, a tent cannot be on top of a tree. Hence, if a tree is on position `(row, col)`, then `x[row, col]` must be $0$.\n\nNext, for every cell `(row, col)` we check whether there is a tree next to this cell. If not, then this cell cannot contain a tent, hence `x[row, col]` should be $0$.\n\n```julia\nfor row in 1:n, col in 1:n\n    # is not on a tree\n    if (row, col) in trees\n        @constraint(model, x[row, col] == 0)\n    end\n\n    # should be next to a tree\n    found = false\n    for tree in trees\n        if abs(tree[1] - row) + abs(tree[2] - col) <= 1\n            found = true\n        end\n    end\n    if !found\n        @constraint(model, x[row, col] == 0)\n    end\nend\n```\n\nThe next constraint makes sure that the number of tents in the rows and columns add up to the right values. This can be done simply by summing the columns and rows of the matrix `x`, since this equals counting the number of ones.\n\n```julia\nfor i in 1:n\n    @constraint(model, sum(x[i, :]) == row_sums[i])\n    @constraint(model, sum(x[:, i]) == col_sums[i])\nend\n```\n\nLastly, we need to encode the fact that the tents may not touch horizontally, vertically or diagonally. In other words, every $2\\times2$ square contains at most one tree, which is also easy to establish using the representation we chose.\n\n```julia\nfor row in 1:(n-1), col in 1:(n-1)\n    @constraint(model, sum(x[row:row+1, col:col+1]) <= 1)\nend\n```\n\n## Solution\n\nNow that we have represented the puzzle as a Linear Program, we can simply tel JuMP to optimize this. Within a second, it spits out a solution. Since Julia supports Unicode characters, we can visualize the solution as a grid of emoji.\n\n```julia\nJuMP.optimize!(model)\n\nsolution = JuMP.value.(x)\n\nfor row in 1:n\n    for col in 1:n\n        if solution[row, col] == 1\n            print(\"â›º\")\n        elseif (row, col) in trees\n            print(\"ðŸŒ²\")\n        else\n            print(\"â—»ï¸\")\n        end\n        print(\" \")\n    end\n    println(\"\")\nend\n```\n\n    â—»ï¸ â—»ï¸ ðŸŒ² â›º â—»ï¸ â›º â—»ï¸ ðŸŒ² ðŸŒ² â›º â—»ï¸ â—»ï¸\n    â—»ï¸ â›º ðŸŒ² â—»ï¸ â—»ï¸ ðŸŒ² â—»ï¸ â›º â—»ï¸ â—»ï¸ ðŸŒ² â›º\n    â—»ï¸ â—»ï¸ â—»ï¸ ðŸŒ² â›º â—»ï¸ â—»ï¸ â—»ï¸ ðŸŒ² â›º â—»ï¸ â—»ï¸\n    â—»ï¸ â›º â—»ï¸ ðŸŒ² â—»ï¸ â—»ï¸ ðŸŒ² â—»ï¸ â—»ï¸ â—»ï¸ â—»ï¸ â—»ï¸\n    â—»ï¸ ðŸŒ² â—»ï¸ â›º â—»ï¸ â—»ï¸ â›º â—»ï¸ â—»ï¸ â—»ï¸ â—»ï¸ â—»ï¸\n    â›º â—»ï¸ ðŸŒ² â—»ï¸ â—»ï¸ â—»ï¸ â—»ï¸ â—»ï¸ ðŸŒ² â›º ðŸŒ² â›º\n    ðŸŒ² â—»ï¸ â›º â—»ï¸ â›º â—»ï¸ â—»ï¸ â—»ï¸ â—»ï¸ â—»ï¸ â—»ï¸ â—»ï¸\n    â—»ï¸ â—»ï¸ â—»ï¸ â—»ï¸ ðŸŒ² â—»ï¸ â—»ï¸ â›º ðŸŒ² â—»ï¸ ðŸŒ² â›º\n    â›º â—»ï¸ ðŸŒ² â—»ï¸ â—»ï¸ â—»ï¸ â—»ï¸ â—»ï¸ â—»ï¸ â›º â—»ï¸ â—»ï¸\n    ðŸŒ² â—»ï¸ â›º â—»ï¸ â—»ï¸ â›º â—»ï¸ â›º â—»ï¸ ðŸŒ² â—»ï¸ â›º\n    â—»ï¸ â—»ï¸ â—»ï¸ â—»ï¸ â—»ï¸ ðŸŒ² â—»ï¸ ðŸŒ² â—»ï¸ â—»ï¸ â—»ï¸ ðŸŒ²\n    â—»ï¸ â—»ï¸ ðŸŒ² â›º â—»ï¸ ðŸŒ² â›º â—»ï¸ ðŸŒ² â›º ðŸŒ² â›º\n\nThat's it! I like the JuMP syntax a lot and will definitely use it to solve more puzzles!\n","srcMarkdownNoYaml":"\n\nTrees and Tents is a logic game in which tents need to be placed in a grid. Every tent must be next to a tree, and tents cannot touch horizontally, vertically or diagonally. For every row and column, the number of tents is given.\n\nThe website https://brainbashers.com/tents.asp posts a new puzzle every day, of which a 12x12 example is the following:\n\n![A 12x12 Trees and Tents puzzle from https://brainbashers.com/tents.asp](/post/2019-04-21-trees-and-tents/example.png){width=70%}\n\nIn this post, I will implement a solver for this puzzle in Julia using the [JuMP](https://github.com/JuliaOpt/JuMP.jl) package for mathematical optimization.\nThe complete code as a jupyter notebook can be found [here](https://github.com/basjacobs93/trees_and_tents).\n\n## Problem definition\n\nThe puzzle can be formulated as a linear programming problem. There are three types of constraints:\n\n - every tent must be next to a tree,\n - the number of tents for every row and column is given,\n - tents are not allowed to touch.\n\nEven though we treat this puzzle as an optimization problem, there is no objective to be maximized or minimized in this case; any placements of tents satisfying the constraints is a valid solution. This is similar to the [sudoku](https://github.com/JuliaOpt/JuMP.jl/blob/master/examples/sudoku.jl) [solutions](https://pythonhosted.org/PuLP/CaseStudies/a_sudoku_problem.html) in which the objective is also unimportant.\n\nJulia's JuMP package provides a clean interface to defining such a problem, and solving it with various solvers. In this case, we use [GLPK](https://www.gnu.org/software/glpk/) since it's free and works great for this problem. Solving the problem is a matter of writing down the constraints and calling `JuMP.optimize`.\n\n```julia\nusing JuMP, GLPK\n```\n\nAfter loading the necessary packages, we need to define the puzzle displayed above. In the website's html code, the puzzle is represented by three strings.\n\n - `lcpuzzle` is a string of numbers, denoting the cells from left to right, top to bottom. The values represent whether the corresponding cell is blank (0), or contains a tree (1) or a tent (2). Note that this string contains the solution to the problem as well, so this allows us to check the solution that JuMP found afterwards.\n - `lcrownumbers` is a string of numbers which denote the number of tents per row.\n - `lcrolnumbers` is a string of numbers which denote the number of tents per column.\n\n```julia\n# from html, 0=blank, 1=tree, 2=tent\nlcpuzzle = \"001202011200021001020012000120001200020100100000010200200000201000001212102020000000000010021012201000000200102002020102000001010001001201201212\"\nlcrownumbers = \"332123222404\"\nlccolnumbers = \"222322230505\"\n```\n\nWe rewrite the above representation into something that is more easy to work with:\n\n - `trees` is a list of `(i,j)` tuples corresponding to the locations of the trees.\n - `row_sums` and `col_sums` are lists of integers denoting the totals per row and column.\n - `n` is the size of the game, which is in this case 12.\n\n```julia\npuzzle = [parse(Int, i) for i in lcpuzzle]\nn = Int(sqrt(length(puzzle)))\n\ntrees = [(i, j) for i in 1:n, j in 1:n if puzzle[(i-1)*n + j] == 1]\nrow_sums = [parse(Int, i) for i in lcrownumbers]\ncol_sums = [parse(Int, i) for i in lccolnumbers]\n```\n\nWe initialize the solver, telling JuMP that we want to use GLPK. The variable that JuMP optimizes over is an $n\\times n$ matrix `x`, consisting of binary values, where a 0 means no tent for that cell, and a 1 means that the cell contains a tent.\n\n\n```julia\nmodel = Model(with_optimizer(GLPK.Optimizer))\n\n@variable(model, x[1:n, 1:n], Bin)\n```\n\n## Constraints\n\nWe are now ready to define the constraints. We start with the requirement that a tent be next to a tree.\n\nFirst, a tent cannot be on top of a tree. Hence, if a tree is on position `(row, col)`, then `x[row, col]` must be $0$.\n\nNext, for every cell `(row, col)` we check whether there is a tree next to this cell. If not, then this cell cannot contain a tent, hence `x[row, col]` should be $0$.\n\n```julia\nfor row in 1:n, col in 1:n\n    # is not on a tree\n    if (row, col) in trees\n        @constraint(model, x[row, col] == 0)\n    end\n\n    # should be next to a tree\n    found = false\n    for tree in trees\n        if abs(tree[1] - row) + abs(tree[2] - col) <= 1\n            found = true\n        end\n    end\n    if !found\n        @constraint(model, x[row, col] == 0)\n    end\nend\n```\n\nThe next constraint makes sure that the number of tents in the rows and columns add up to the right values. This can be done simply by summing the columns and rows of the matrix `x`, since this equals counting the number of ones.\n\n```julia\nfor i in 1:n\n    @constraint(model, sum(x[i, :]) == row_sums[i])\n    @constraint(model, sum(x[:, i]) == col_sums[i])\nend\n```\n\nLastly, we need to encode the fact that the tents may not touch horizontally, vertically or diagonally. In other words, every $2\\times2$ square contains at most one tree, which is also easy to establish using the representation we chose.\n\n```julia\nfor row in 1:(n-1), col in 1:(n-1)\n    @constraint(model, sum(x[row:row+1, col:col+1]) <= 1)\nend\n```\n\n## Solution\n\nNow that we have represented the puzzle as a Linear Program, we can simply tel JuMP to optimize this. Within a second, it spits out a solution. Since Julia supports Unicode characters, we can visualize the solution as a grid of emoji.\n\n```julia\nJuMP.optimize!(model)\n\nsolution = JuMP.value.(x)\n\nfor row in 1:n\n    for col in 1:n\n        if solution[row, col] == 1\n            print(\"â›º\")\n        elseif (row, col) in trees\n            print(\"ðŸŒ²\")\n        else\n            print(\"â—»ï¸\")\n        end\n        print(\" \")\n    end\n    println(\"\")\nend\n```\n\n    â—»ï¸ â—»ï¸ ðŸŒ² â›º â—»ï¸ â›º â—»ï¸ ðŸŒ² ðŸŒ² â›º â—»ï¸ â—»ï¸\n    â—»ï¸ â›º ðŸŒ² â—»ï¸ â—»ï¸ ðŸŒ² â—»ï¸ â›º â—»ï¸ â—»ï¸ ðŸŒ² â›º\n    â—»ï¸ â—»ï¸ â—»ï¸ ðŸŒ² â›º â—»ï¸ â—»ï¸ â—»ï¸ ðŸŒ² â›º â—»ï¸ â—»ï¸\n    â—»ï¸ â›º â—»ï¸ ðŸŒ² â—»ï¸ â—»ï¸ ðŸŒ² â—»ï¸ â—»ï¸ â—»ï¸ â—»ï¸ â—»ï¸\n    â—»ï¸ ðŸŒ² â—»ï¸ â›º â—»ï¸ â—»ï¸ â›º â—»ï¸ â—»ï¸ â—»ï¸ â—»ï¸ â—»ï¸\n    â›º â—»ï¸ ðŸŒ² â—»ï¸ â—»ï¸ â—»ï¸ â—»ï¸ â—»ï¸ ðŸŒ² â›º ðŸŒ² â›º\n    ðŸŒ² â—»ï¸ â›º â—»ï¸ â›º â—»ï¸ â—»ï¸ â—»ï¸ â—»ï¸ â—»ï¸ â—»ï¸ â—»ï¸\n    â—»ï¸ â—»ï¸ â—»ï¸ â—»ï¸ ðŸŒ² â—»ï¸ â—»ï¸ â›º ðŸŒ² â—»ï¸ ðŸŒ² â›º\n    â›º â—»ï¸ ðŸŒ² â—»ï¸ â—»ï¸ â—»ï¸ â—»ï¸ â—»ï¸ â—»ï¸ â›º â—»ï¸ â—»ï¸\n    ðŸŒ² â—»ï¸ â›º â—»ï¸ â—»ï¸ â›º â—»ï¸ â›º â—»ï¸ ðŸŒ² â—»ï¸ â›º\n    â—»ï¸ â—»ï¸ â—»ï¸ â—»ï¸ â—»ï¸ ðŸŒ² â—»ï¸ ðŸŒ² â—»ï¸ â—»ï¸ â—»ï¸ ðŸŒ²\n    â—»ï¸ â—»ï¸ ðŸŒ² â›º â—»ï¸ ðŸŒ² â›º â—»ï¸ ðŸŒ² â›º ðŸŒ² â›º\n\nThat's it! I like the JuMP syntax a lot and will definitely use it to solve more puzzles!\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":true,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"markdown"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["../../styles.css"],"toc":true,"html-math-method":"katex","output-file":"index.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.7.33","theme":["cosmo","brand"],"respect-user-color-scheme":true,"title":"Trees and Tents","author":"Bas","date":"2019-04-21"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}