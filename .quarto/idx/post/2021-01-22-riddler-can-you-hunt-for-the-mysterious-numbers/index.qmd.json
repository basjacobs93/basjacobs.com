{"title":"Riddler: Can You Hunt For The Mysterious Numbers?","markdown":{"yaml":{"title":"Riddler: Can You Hunt For The Mysterious Numbers?","author":"Bas","date":"2021-01-22"},"headingText":"Linear programming","containsRefs":false,"markdown":"\n\nThis week's [FiveThirtyEight Riddler Classic](https://fivethirtyeight.com/features/can-you-hunt-for-the-mysterious-numbers/) offers a sudoku-like puzzle:\n\n> There are eight three-digit numbers --- each belongs in a row of the table below, with one digit per cell. The products of the three digits of each number are shown in the rightmost column. Meanwhile, the products of the digits in the hundreds, tens, and ones places, respectively, are shown in the bottom row.\n> Can you find all eight three-digit numbers and complete the table? It's a bit of a mystery, but I'm sure you have it within you to hunt down the answer!\n\n![](https://fivethirtyeight.com/wp-content/uploads/2021/01/RIDDLER.011521.png?w=1400){width=\"500\"}\n\n\nA nice way to solve problems like this is by Integer Linear Programming. Like in my [Trees and Tents post](/post/2019-04-21-trees-and-tents/), I like to do this in Julia using the JuMP package.\n\nThe constraints we have are on the products of the numbers in the rows and the columns. Therefore the problem is not linear if we implement it naively (a variable for every cell denoting the number between 1 and 9 it should contain). We need to do something a little bit more clever. A natural way to look at this problem is via the prime factorizations of the row and the column products. There are four primes between 1 and 9, namely 2, 3, 5 and 7. Given the prime factorization of every row and column, we only need to distribute these primes over the cells. Since $294 = 2^1\\cdot 3^1\\cdot 5^0 \\cdot 7^2$, we know that in the first row there should be a 2, a 3, no 5 and two 7s. Note that a cell can contain multiple primes, or none at all (meaning it is a 1).\n\nWe therefore need a variable for every cell and each of the 4 possible primes, the value of which denotes the multiplicity of this prime in this cell.\n\nIn Julia, we first import the required packages, and define the row and column products.\n\n```julia\nusing JuMP, GLPK\nusing Primes: factor, primes\nusing DataStructures: DefaultDict\n\nrow_prods = [294, 216, 135, 98, 112, 84, 245, 40];\ncol_prods = [8_890_560, 156_800, 55_566];\nprms = primes(1, 9);\n\nn_prms = length(prms);\nn_rows = length(row_prods);\nn_cols = length(col_prods);\n```\n\nNow, we create lists of the multiplicities of the four primes in the rows and the columns. The `[1, 1, 0, 2]` denotes the multiplicities of 2, 3, 5 and 7 in the first row.\n\n```julia\nrow_factors = factor.(Dict, row_prods);\ncol_factors = factor.(Dict, col_prods);\n\nrow_factors = [[DefaultDict(0, row_factors[row])[prms[i]] for i in 1:4] for row in 1:n_rows]\ncol_factors = [[DefaultDict(0, col_factors[col])[prms[i]] for i in 1:4] for col in 1:n_cols]\n```\n```\n8-element Array{Array{Int64,1},1}:\n [1, 1, 0, 2]\n [3, 3, 0, 0]\n [0, 3, 1, 0]\n [1, 0, 0, 2]\n [4, 0, 0, 1]\n [2, 1, 0, 1]\n [0, 0, 1, 2]\n [3, 0, 1, 0]\n3-element Array{Array{Int64,1},1}:\n [6, 4, 1, 3]\n [7, 0, 2, 2]\n [1, 4, 0, 3]\n ```\n\nNow onto the actual problem definition. As stated, we need a variable for every cell and every prime. Every prime can occur 0 or more times, and its multiplicity is an integer.\n\n```julia\nmodel = Model(with_optimizer(GLPK.Optimizer))\n\n@variable(model, 0 <= x[1:n_rows, 1:n_cols, 1:n_prms], integer=true)\n```\n\nRows and column prime multiplicities should add up to the correct numbers.\n\n```julia\nfor i in 1:n_rows, p in 1:n_prms\n    @constraint(model, sum(x[i, :, p]) == row_factors[i][p])\nend\n\nfor j in 1:n_cols, p in 1:n_prms\n    @constraint(model, sum(x[:, j, p]) == col_factors[j][p])\nend\n```\n\nFinally, we want every cell to be an integer between 1 and 9, which means $2^{p_2}\\cdot 3^{p_3}\\cdot 5^{p_5}\\cdot 7^{p_7} \\le 9$, or $p_2\\log(2) + p_3\\log(3) + p_5\\log(5)+p_7\\log(7) \\le \\log(9)$, a constraint which is linear in its variables.\n\n```julia\nfor i in 1:n_rows, j in 1:n_cols\n\t@constraint(model, sum(x[i, j, :] .* log.(prms)) <= log(9))\nend\n```\n\nAnd that is all! We let JuMP do the hard work and come up with a feasible solution. As an example, we print out the number of times a 2 (the first prime) appears in every cell.\n\n```julia\nJuMP.optimize!(model)\n\nsolution = JuMP.value.(x);\n\nsolution[:, :, 1]\n```\n```\n8×3 Array{Float64,2}:\n 0.0  0.0  1.0\n 0.0  3.0  0.0\n 0.0  0.0  0.0\n 0.0  1.0  0.0\n 3.0  1.0  0.0\n 0.0  2.0  0.0\n 0.0  0.0  0.0\n 3.0  0.0  0.0\n```\n\nThe final solution to the riddle is then the product of every prime to the power of its multiplicity:\n\n```julia\n[[Int(prod(prms .^ solution[i, j, :])) for j in 1:n_cols] for i in 1:n_rows]\n```\n```\n8-element Array{Array{Int64,1},1}:\n [7, 7, 6]\n [9, 8, 3]\n [9, 5, 3]\n [7, 2, 7]\n [8, 2, 7]\n [7, 4, 3]\n [5, 7, 7]\n [8, 5, 1]\n```\n\nAnd there's the solution! I love how easy it is to have JuMP solve such a problem after coming up with a way to phrase it as a linear program.\n","srcMarkdownNoYaml":"\n\nThis week's [FiveThirtyEight Riddler Classic](https://fivethirtyeight.com/features/can-you-hunt-for-the-mysterious-numbers/) offers a sudoku-like puzzle:\n\n> There are eight three-digit numbers --- each belongs in a row of the table below, with one digit per cell. The products of the three digits of each number are shown in the rightmost column. Meanwhile, the products of the digits in the hundreds, tens, and ones places, respectively, are shown in the bottom row.\n> Can you find all eight three-digit numbers and complete the table? It's a bit of a mystery, but I'm sure you have it within you to hunt down the answer!\n\n![](https://fivethirtyeight.com/wp-content/uploads/2021/01/RIDDLER.011521.png?w=1400){width=\"500\"}\n\n## Linear programming\n\nA nice way to solve problems like this is by Integer Linear Programming. Like in my [Trees and Tents post](/post/2019-04-21-trees-and-tents/), I like to do this in Julia using the JuMP package.\n\nThe constraints we have are on the products of the numbers in the rows and the columns. Therefore the problem is not linear if we implement it naively (a variable for every cell denoting the number between 1 and 9 it should contain). We need to do something a little bit more clever. A natural way to look at this problem is via the prime factorizations of the row and the column products. There are four primes between 1 and 9, namely 2, 3, 5 and 7. Given the prime factorization of every row and column, we only need to distribute these primes over the cells. Since $294 = 2^1\\cdot 3^1\\cdot 5^0 \\cdot 7^2$, we know that in the first row there should be a 2, a 3, no 5 and two 7s. Note that a cell can contain multiple primes, or none at all (meaning it is a 1).\n\nWe therefore need a variable for every cell and each of the 4 possible primes, the value of which denotes the multiplicity of this prime in this cell.\n\nIn Julia, we first import the required packages, and define the row and column products.\n\n```julia\nusing JuMP, GLPK\nusing Primes: factor, primes\nusing DataStructures: DefaultDict\n\nrow_prods = [294, 216, 135, 98, 112, 84, 245, 40];\ncol_prods = [8_890_560, 156_800, 55_566];\nprms = primes(1, 9);\n\nn_prms = length(prms);\nn_rows = length(row_prods);\nn_cols = length(col_prods);\n```\n\nNow, we create lists of the multiplicities of the four primes in the rows and the columns. The `[1, 1, 0, 2]` denotes the multiplicities of 2, 3, 5 and 7 in the first row.\n\n```julia\nrow_factors = factor.(Dict, row_prods);\ncol_factors = factor.(Dict, col_prods);\n\nrow_factors = [[DefaultDict(0, row_factors[row])[prms[i]] for i in 1:4] for row in 1:n_rows]\ncol_factors = [[DefaultDict(0, col_factors[col])[prms[i]] for i in 1:4] for col in 1:n_cols]\n```\n```\n8-element Array{Array{Int64,1},1}:\n [1, 1, 0, 2]\n [3, 3, 0, 0]\n [0, 3, 1, 0]\n [1, 0, 0, 2]\n [4, 0, 0, 1]\n [2, 1, 0, 1]\n [0, 0, 1, 2]\n [3, 0, 1, 0]\n3-element Array{Array{Int64,1},1}:\n [6, 4, 1, 3]\n [7, 0, 2, 2]\n [1, 4, 0, 3]\n ```\n\nNow onto the actual problem definition. As stated, we need a variable for every cell and every prime. Every prime can occur 0 or more times, and its multiplicity is an integer.\n\n```julia\nmodel = Model(with_optimizer(GLPK.Optimizer))\n\n@variable(model, 0 <= x[1:n_rows, 1:n_cols, 1:n_prms], integer=true)\n```\n\nRows and column prime multiplicities should add up to the correct numbers.\n\n```julia\nfor i in 1:n_rows, p in 1:n_prms\n    @constraint(model, sum(x[i, :, p]) == row_factors[i][p])\nend\n\nfor j in 1:n_cols, p in 1:n_prms\n    @constraint(model, sum(x[:, j, p]) == col_factors[j][p])\nend\n```\n\nFinally, we want every cell to be an integer between 1 and 9, which means $2^{p_2}\\cdot 3^{p_3}\\cdot 5^{p_5}\\cdot 7^{p_7} \\le 9$, or $p_2\\log(2) + p_3\\log(3) + p_5\\log(5)+p_7\\log(7) \\le \\log(9)$, a constraint which is linear in its variables.\n\n```julia\nfor i in 1:n_rows, j in 1:n_cols\n\t@constraint(model, sum(x[i, j, :] .* log.(prms)) <= log(9))\nend\n```\n\nAnd that is all! We let JuMP do the hard work and come up with a feasible solution. As an example, we print out the number of times a 2 (the first prime) appears in every cell.\n\n```julia\nJuMP.optimize!(model)\n\nsolution = JuMP.value.(x);\n\nsolution[:, :, 1]\n```\n```\n8×3 Array{Float64,2}:\n 0.0  0.0  1.0\n 0.0  3.0  0.0\n 0.0  0.0  0.0\n 0.0  1.0  0.0\n 3.0  1.0  0.0\n 0.0  2.0  0.0\n 0.0  0.0  0.0\n 3.0  0.0  0.0\n```\n\nThe final solution to the riddle is then the product of every prime to the power of its multiplicity:\n\n```julia\n[[Int(prod(prms .^ solution[i, j, :])) for j in 1:n_cols] for i in 1:n_rows]\n```\n```\n8-element Array{Array{Int64,1},1}:\n [7, 7, 6]\n [9, 8, 3]\n [9, 5, 3]\n [7, 2, 7]\n [8, 2, 7]\n [7, 4, 3]\n [5, 7, 7]\n [8, 5, 1]\n```\n\nAnd there's the solution! I love how easy it is to have JuMP solve such a problem after coming up with a way to phrase it as a linear program.\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":true,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"markdown"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["../../styles.css"],"toc":true,"html-math-method":"katex","output-file":"index.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.7.33","theme":["cosmo"],"respect-user-color-scheme":true,"title":"Riddler: Can You Hunt For The Mysterious Numbers?","author":"Bas","date":"2021-01-22"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}