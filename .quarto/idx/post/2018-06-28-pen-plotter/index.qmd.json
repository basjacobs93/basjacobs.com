{"title":"Pen plotter","markdown":{"yaml":{"title":"Pen plotter","author":"Bas","date":"2018-06-28"},"headingText":"Buying and assembling","containsRefs":false,"markdown":"\n\nInspired by [this](http://www.tobiastoft.com/posts/an-intro-to-pen-plotters) blog post, I got interested in pen plotters and computer generated art. I liked the minimalist pieces of art a plotter could create, resembling a human hand doodling on a piece of paper. A lot of examples of this art can be found on Twitter at [#plottertwitter](https://twitter.com/hashtag/plottertwitter). By far the most used plotter on Twitter is the [AxiDraw](https://www.axidraw.com/), but since I didn't want to spend over 400 euros and I liked the prospect of assembling something myself, I decided to buy the [EleksDraw](http://eleksmaker.com/nav/eleksdraw/) which was around 100 euros and came completely unassembled. In this blog post, I am summarising the steps I took to go from a box with nuts and bolts to some nice drawings on paper, hopefully inspiring you to try this out as well. Most of the code used can be found on [my GitHub](https://github.com/basjacobs93/plotter). Note that I wrote this code for myself, so please only use it as a reference and don't use it without understanding what is going on.\n\nI ordered the EleksDraw from BangGood, which means that the product came from China and took around 3 weeks to arrive. It came in more than a hundred pieces and assembling it took me a couple of hours. The instructions on the website were just clear enough; they consisted of just a series of pictures with no text.\n\nThe EleksDraw consists of an arm that is connected via a cable to two motors which together can move the arm in the x and y direction. You can mount any pen or pencil to it which is held in place by a screw.\nAfter assembling it and hooking it up to my computer, I downloaded the EleksMaker software that can be used to convert an image to commands that this plotter can interpret. However, this software only works on Windows (I'm on a MacBook), and even after booting into Windows, it did not work as it should. Most of the menus didn't show any text and when loading an image, I got an error that I couldn't understand because it was in Chinese.\nI decided to boot back into MacOS and create some software myself. How hard could it be, right?\n\n![The assembled EleksDraw should look a little something like this](/post/2018-06-28-pen-plotter/plotter.jpg){width=600px}\n\n\n# Hello, World!\nThe MacOS terminal has a `screen` command that allows you to send commands to an external device. In my case, typing `screen /dev/wchusbserial1420` connects with the EleksDraw and opens a terminal in which I could write commands.\nThe language that this plotter understands is called G-code. With this code, you can give the device the following commands:\n\n- `S0 M5` lifts the pen\n- `S1000 M3` lowers the pen\n- `G01 Xa Yb` moves to position (a,b)\n\nNote that G-code has many variants, so the above commands may not be exactly the same for other pen plotters.\nWeirdly, the plotter's `(0,0)` position was in the top right corner, so I had to make all the coordinates negative to get it to work properly. Could be because I somehow wired it wrong, but I could not figure it out. Anyway, writing my own software allowed me to work around this very easily!\nWriting these instructions one by one, I could create all kinds of shapes consisting of straight lines. After every command I wrote, the device would either send back the message `ok` or an error. After this response, I could send it a new instruction. However, I wanted to automatically generate these commands and send them to the device using a script.\n\n## Plotter meets Python\nUsing the Python package [pySerial](https://github.com/pyserial/pyserial), I was able to send commands to the plotter through just a couple of lines of code (see [here](https://github.com/grbl/grbl/blob/master/doc/script/simple_stream.py)):\n\n```python\n# Open serial port\ns = serial.Serial('/dev/wchusbserial1420', 115200)\n\n# Wake up\ns.write(\"\\r\\n\\r\\n\")\ntime.sleep(2)       # wait for grbl to initialize\ns.flushInput()      # flush startup text in serial input\n\ns.write(\"G21\\n\")   # units = mm\ns.readline()\n\ns.write(\"F5000\\n\") # speed = 5000 mm/min\ns.readline()\n\ns.write(\"S0 M5\\n\") # pen up\ns.readline()\n\ns.write(\"G01 X-10 Y-10\\n\") # go to (10, 10)\ns.readline()\n\ns.write(\"S1000 M3\\n\") # pen down\ns.readline()\n\ns.write(\"G01 X-20 Y-10\\n\") # go to (20, 10)\ns.readline()\n\ns.write(\"S0 M5\\n\") # pen up\ns.readline()\n```\n\nThis piece of code wakes up the plotter, raises the pen, moves to `(10, 10)` (note I wrote -10 for reasons described above), lowers the pen, moves to `(20, 10)` and finally raises the pen again. Effectively, this draws a straight line from `(10mm, 10mm)` to `(20mm, 10mm)`.\nSince I figured I would be needing this code more, I wrapped it in a function. I decided to go object-oriented and created classes `Point` and `Line`, respectively. For now, these classes only contained `draw` methods, but I knew more was going to be needed.\n\n# Plotting SVGs\n\nBack to my original idea: I wanted to be able to load an image, convert it to G-code commands and send these commands to the plotter automatically. Using SVG images as input seemed like the right choice since these are vector graphics and hence should be easy to convert to G-code. First step: writing an SVG parser.\n\n## Lines and points\nWhat seemed most intuitive to me was converting the SVG `<path>` element to G-code instructions. Such an element can contain various types of lines and curves that together create a connected (closed or open) path. A path like this can be constructed by tracing an image in a tool like Inkscape or Sketch. My final goal was to be able to plot Picasso's drawing 'Dog', which could be traced with a single path.\n\n![Dog (Picasso), pen on paper](/post/2018-06-28-pen-plotter/picassodog.jpg){width=600px}\n\nAn example of the SVG path syntax can be found on [w3schools](https://www.w3schools.com/graphics/svg_path.asp).\nIt turned out that parsing such a path was straightforward with regular expressions. There were three things that made things slightly more complicated.\n\n1. Different instructions can have different numbers of parameters. For example, the `M` command (move) takes two numbers (an x and y coordinate), the `Z` (close path) command takes zero parameters, and some curve commands can take up to 7 parameters.\n2. A command letter does not need to be repeated. For example, `L 10 20 10 30` draws a line from the current position to `(10, 20)` and then another line to `(10, 30)` and is the same as `L 10 20 L 10 30`.\n3. All commands can also be expressed with lower case letters, referring to relative instead of absolute positions. This requires a post processing step in which we keep track of the current position and add it if a relative position was supplied.\n\nAll of these issues were relatively easy to overcome, and after implementing this, I was able to parse an SVG file into a table which I could then convert to G-code. The code for this parser can be found on my GitHub.\n\n## Bézier curves\nStill, I had only created code for drawing points and lines. To plot arcs, I could of course interpolate these using points, but the results were what I expected them to be: not very pretty. G-code supports circle arcs (an arc obtained by tracing part of a circle), so a better way would be to try to approximate the curves using circle arcs.\nWhen tracing an image with a vector graphics tool like Sketch or Inkscape, the result will be a path consisting of [Bézier curves](https://en.wikipedia.org/wiki/B%C3%A9zier_curve). A Bézier curve is a parametric curve that can be described mathematically. I won't go into more detail on Bézier curves; that is worth a blog post in itself. One thing that's important to know is that there are quadratic and cubic Bézier curves. The quadratic curves are a special case of the cubic ones, so if I'm able to draw cubic Bézier curves I'm able to draw both.\n\n![A cubic Bézier curve is defined by 4 points (source: Wikipedia)](/post/2018-06-28-pen-plotter/cubic_bezier.png){width=600px}\n\nIt is in general not possible to convert a Bézier curve to a combination of circle arcs, but there are ways that are 'good enough'. In particular, I implemented [this](http://dlacko.org/blog/2016/10/19/approximating-bezier-curves-by-biarcs/) approach in Python, which approximates a cubic Bézier curve with two circle arcs. I updated the classes for points and lines to include addition of points, multiplication of points with scalars, intersections of lines and so on. After these adjustments, it was relatively straightforward to write a `CubicBezier` class of which an instantiation could convert itself to two objects of class `CircleArc`.\nFor debugging purposes, I gave every such class a method that could draw the corresponding shape on a PyGame canvas. That way, I had a way of testing if everything worked without having to go through stacks of paper. In the end, this also allowed me to check if the thing I was going to plot looked the way it should, before actually sending it to the EleksDraw. For example, find below the code for `Line`.\n\n```python\nimport plotter as plt\n\nclass Line():\n    # a line is defined by 2 points\n    def __init__(self, point1, point2):\n        self.P1 = point1\n        self.P2 = point2\n\n    def intersect(self, line2):\n        # calculates the intersection point of the lines\n        # solution is based on simple algebra\n        a = self.P1.x - self.P2.x\n        b = self.P1.y - self.P2.y\n\n        u = (a*(line2.P2.y-self.P2.y) - b*(line2.P2.x-self.P2.x)) /\\\n            (a*(line2.P2.y-line2.P1.y) - b*(line2.P2.x-line2.P1.x))\n\n        return (line2.P1.times(u)).plus(line2.P2.times(1-u))\n\n    def perpendicular_at(self, P):\n        U = Point(self.P2.y-self.P1.y, self.P1.x - self.P2.x)\n        return Line(P, P.plus(U))\n\n    def draw(self, canvas, color):\n        pygame.draw.line(canvas, color,\n                         (self.P1.x, canvas.get_height()-self.P1.y),\n                         (self.P2.x, canvas.get_height()-self.P2.y))\n\n    def plot_instructions(self):\n        # assumes we are at P1\n        return [plt.move(self.P2.x, self.P2.y)]\n```\n\nAfter all this work, I was finally able to plot Picasso's dog.\n\n![Dog (Picasso/EleksDraw), pen on paper](/post/2018-06-28-pen-plotter/picassodog_plot.png){width=600px}\n\n# Drawing a harmonograph\nAnother [blog post](https://aschinchon.wordpress.com/2014/10/13/beautiful-curves-the-harmonograph/) inspired me to try and plot some harmonographs. A harmonograph is a device that uses pendulums to draw trajectories on a piece of paper. The output of such a harmonograph can be described mathematically and we can simulate a random harmonograph by drawing random numbers and following a trajectory defined by sine waves. I followed the blog post mentioned above which draws 12 random numbers and plots the trajectory defined by\n\n$$ x(t)=e^{-d_1t}\\sin(tf_1+p_1)+e^{-d_2t}\\sin(tf_2+p_2)$$\n$$y(t)=e^{-d_3t}\\sin(tf_3+p_3)+e^{-d_4t}\\sin(tf_4+p_4)$$\nwhere $t$ runs from $0$ to $1$.\nIn his post, the author implemented the harmonograph in R, but since my plotter works from Python, I ported his code to Python.\n\n```python\nimport numpy as np\n\n# draw the necessary random numbers\nf1, f2, f3, f4 = np.random.randint(2, 4, size=4) + (np.random.random(size=4)-0.5) / 10\nd1, d2, d3, d4 = np.random.uniform(0, 1e-02, 4)\np1, p2, p3, p4 = np.random.uniform(0, np.pi, 4)\n\n# define the space and follow the trajectory\nt = np.linspace(1, 100, num = 10**4)\nxs = xt(t)\nys = yt(t)\n```\nAfter this, I could plot the curve by defining lines between subsequent points and sending the instructions to my plotter. Using the classes and functions I defined before, this was very easy:\n\n```python\nobjs = [shapes.Point(xs[0], ys[0])] +\\\n  [shapes.Line(\n      shapes.Point(xs[i], ys[i]),\n      shapes.Point(xs[i+1], ys[i+1])\n   ) for i in range(len(xs)-1)]\n\ns = wake_up_serial('/dev/tty.wchusbserial1410', 115200)\nobjs_to_plotter(objs, s)\n```\n\nNote that I started with a `Point` because the pen needs to move to the initial position before it can start drawing. If you look carefully, you can see that the figure was built up using small line segments. Increasing the number of steps in the `np.linspace` command above will make the result smoother. Nevertheless, I think the result looks very nice!\n\n![Harmonograph, pen on paper](/post/2018-06-28-pen-plotter/harmonograph.jpg){width=600px}\n\n# Conclusion\n\nAll in all, it was a nice journey. I never considered myself an artist, but now I kind of know what it feels like to be one, even though I did not design anything by hand.\nSomeday, I want to learn [Processing](https://processing.org/), a programming language designed specifically for creating computer generated art.\n","srcMarkdownNoYaml":"\n\nInspired by [this](http://www.tobiastoft.com/posts/an-intro-to-pen-plotters) blog post, I got interested in pen plotters and computer generated art. I liked the minimalist pieces of art a plotter could create, resembling a human hand doodling on a piece of paper. A lot of examples of this art can be found on Twitter at [#plottertwitter](https://twitter.com/hashtag/plottertwitter). By far the most used plotter on Twitter is the [AxiDraw](https://www.axidraw.com/), but since I didn't want to spend over 400 euros and I liked the prospect of assembling something myself, I decided to buy the [EleksDraw](http://eleksmaker.com/nav/eleksdraw/) which was around 100 euros and came completely unassembled. In this blog post, I am summarising the steps I took to go from a box with nuts and bolts to some nice drawings on paper, hopefully inspiring you to try this out as well. Most of the code used can be found on [my GitHub](https://github.com/basjacobs93/plotter). Note that I wrote this code for myself, so please only use it as a reference and don't use it without understanding what is going on.\n\n# Buying and assembling\nI ordered the EleksDraw from BangGood, which means that the product came from China and took around 3 weeks to arrive. It came in more than a hundred pieces and assembling it took me a couple of hours. The instructions on the website were just clear enough; they consisted of just a series of pictures with no text.\n\nThe EleksDraw consists of an arm that is connected via a cable to two motors which together can move the arm in the x and y direction. You can mount any pen or pencil to it which is held in place by a screw.\nAfter assembling it and hooking it up to my computer, I downloaded the EleksMaker software that can be used to convert an image to commands that this plotter can interpret. However, this software only works on Windows (I'm on a MacBook), and even after booting into Windows, it did not work as it should. Most of the menus didn't show any text and when loading an image, I got an error that I couldn't understand because it was in Chinese.\nI decided to boot back into MacOS and create some software myself. How hard could it be, right?\n\n![The assembled EleksDraw should look a little something like this](/post/2018-06-28-pen-plotter/plotter.jpg){width=600px}\n\n\n# Hello, World!\nThe MacOS terminal has a `screen` command that allows you to send commands to an external device. In my case, typing `screen /dev/wchusbserial1420` connects with the EleksDraw and opens a terminal in which I could write commands.\nThe language that this plotter understands is called G-code. With this code, you can give the device the following commands:\n\n- `S0 M5` lifts the pen\n- `S1000 M3` lowers the pen\n- `G01 Xa Yb` moves to position (a,b)\n\nNote that G-code has many variants, so the above commands may not be exactly the same for other pen plotters.\nWeirdly, the plotter's `(0,0)` position was in the top right corner, so I had to make all the coordinates negative to get it to work properly. Could be because I somehow wired it wrong, but I could not figure it out. Anyway, writing my own software allowed me to work around this very easily!\nWriting these instructions one by one, I could create all kinds of shapes consisting of straight lines. After every command I wrote, the device would either send back the message `ok` or an error. After this response, I could send it a new instruction. However, I wanted to automatically generate these commands and send them to the device using a script.\n\n## Plotter meets Python\nUsing the Python package [pySerial](https://github.com/pyserial/pyserial), I was able to send commands to the plotter through just a couple of lines of code (see [here](https://github.com/grbl/grbl/blob/master/doc/script/simple_stream.py)):\n\n```python\n# Open serial port\ns = serial.Serial('/dev/wchusbserial1420', 115200)\n\n# Wake up\ns.write(\"\\r\\n\\r\\n\")\ntime.sleep(2)       # wait for grbl to initialize\ns.flushInput()      # flush startup text in serial input\n\ns.write(\"G21\\n\")   # units = mm\ns.readline()\n\ns.write(\"F5000\\n\") # speed = 5000 mm/min\ns.readline()\n\ns.write(\"S0 M5\\n\") # pen up\ns.readline()\n\ns.write(\"G01 X-10 Y-10\\n\") # go to (10, 10)\ns.readline()\n\ns.write(\"S1000 M3\\n\") # pen down\ns.readline()\n\ns.write(\"G01 X-20 Y-10\\n\") # go to (20, 10)\ns.readline()\n\ns.write(\"S0 M5\\n\") # pen up\ns.readline()\n```\n\nThis piece of code wakes up the plotter, raises the pen, moves to `(10, 10)` (note I wrote -10 for reasons described above), lowers the pen, moves to `(20, 10)` and finally raises the pen again. Effectively, this draws a straight line from `(10mm, 10mm)` to `(20mm, 10mm)`.\nSince I figured I would be needing this code more, I wrapped it in a function. I decided to go object-oriented and created classes `Point` and `Line`, respectively. For now, these classes only contained `draw` methods, but I knew more was going to be needed.\n\n# Plotting SVGs\n\nBack to my original idea: I wanted to be able to load an image, convert it to G-code commands and send these commands to the plotter automatically. Using SVG images as input seemed like the right choice since these are vector graphics and hence should be easy to convert to G-code. First step: writing an SVG parser.\n\n## Lines and points\nWhat seemed most intuitive to me was converting the SVG `<path>` element to G-code instructions. Such an element can contain various types of lines and curves that together create a connected (closed or open) path. A path like this can be constructed by tracing an image in a tool like Inkscape or Sketch. My final goal was to be able to plot Picasso's drawing 'Dog', which could be traced with a single path.\n\n![Dog (Picasso), pen on paper](/post/2018-06-28-pen-plotter/picassodog.jpg){width=600px}\n\nAn example of the SVG path syntax can be found on [w3schools](https://www.w3schools.com/graphics/svg_path.asp).\nIt turned out that parsing such a path was straightforward with regular expressions. There were three things that made things slightly more complicated.\n\n1. Different instructions can have different numbers of parameters. For example, the `M` command (move) takes two numbers (an x and y coordinate), the `Z` (close path) command takes zero parameters, and some curve commands can take up to 7 parameters.\n2. A command letter does not need to be repeated. For example, `L 10 20 10 30` draws a line from the current position to `(10, 20)` and then another line to `(10, 30)` and is the same as `L 10 20 L 10 30`.\n3. All commands can also be expressed with lower case letters, referring to relative instead of absolute positions. This requires a post processing step in which we keep track of the current position and add it if a relative position was supplied.\n\nAll of these issues were relatively easy to overcome, and after implementing this, I was able to parse an SVG file into a table which I could then convert to G-code. The code for this parser can be found on my GitHub.\n\n## Bézier curves\nStill, I had only created code for drawing points and lines. To plot arcs, I could of course interpolate these using points, but the results were what I expected them to be: not very pretty. G-code supports circle arcs (an arc obtained by tracing part of a circle), so a better way would be to try to approximate the curves using circle arcs.\nWhen tracing an image with a vector graphics tool like Sketch or Inkscape, the result will be a path consisting of [Bézier curves](https://en.wikipedia.org/wiki/B%C3%A9zier_curve). A Bézier curve is a parametric curve that can be described mathematically. I won't go into more detail on Bézier curves; that is worth a blog post in itself. One thing that's important to know is that there are quadratic and cubic Bézier curves. The quadratic curves are a special case of the cubic ones, so if I'm able to draw cubic Bézier curves I'm able to draw both.\n\n![A cubic Bézier curve is defined by 4 points (source: Wikipedia)](/post/2018-06-28-pen-plotter/cubic_bezier.png){width=600px}\n\nIt is in general not possible to convert a Bézier curve to a combination of circle arcs, but there are ways that are 'good enough'. In particular, I implemented [this](http://dlacko.org/blog/2016/10/19/approximating-bezier-curves-by-biarcs/) approach in Python, which approximates a cubic Bézier curve with two circle arcs. I updated the classes for points and lines to include addition of points, multiplication of points with scalars, intersections of lines and so on. After these adjustments, it was relatively straightforward to write a `CubicBezier` class of which an instantiation could convert itself to two objects of class `CircleArc`.\nFor debugging purposes, I gave every such class a method that could draw the corresponding shape on a PyGame canvas. That way, I had a way of testing if everything worked without having to go through stacks of paper. In the end, this also allowed me to check if the thing I was going to plot looked the way it should, before actually sending it to the EleksDraw. For example, find below the code for `Line`.\n\n```python\nimport plotter as plt\n\nclass Line():\n    # a line is defined by 2 points\n    def __init__(self, point1, point2):\n        self.P1 = point1\n        self.P2 = point2\n\n    def intersect(self, line2):\n        # calculates the intersection point of the lines\n        # solution is based on simple algebra\n        a = self.P1.x - self.P2.x\n        b = self.P1.y - self.P2.y\n\n        u = (a*(line2.P2.y-self.P2.y) - b*(line2.P2.x-self.P2.x)) /\\\n            (a*(line2.P2.y-line2.P1.y) - b*(line2.P2.x-line2.P1.x))\n\n        return (line2.P1.times(u)).plus(line2.P2.times(1-u))\n\n    def perpendicular_at(self, P):\n        U = Point(self.P2.y-self.P1.y, self.P1.x - self.P2.x)\n        return Line(P, P.plus(U))\n\n    def draw(self, canvas, color):\n        pygame.draw.line(canvas, color,\n                         (self.P1.x, canvas.get_height()-self.P1.y),\n                         (self.P2.x, canvas.get_height()-self.P2.y))\n\n    def plot_instructions(self):\n        # assumes we are at P1\n        return [plt.move(self.P2.x, self.P2.y)]\n```\n\nAfter all this work, I was finally able to plot Picasso's dog.\n\n![Dog (Picasso/EleksDraw), pen on paper](/post/2018-06-28-pen-plotter/picassodog_plot.png){width=600px}\n\n# Drawing a harmonograph\nAnother [blog post](https://aschinchon.wordpress.com/2014/10/13/beautiful-curves-the-harmonograph/) inspired me to try and plot some harmonographs. A harmonograph is a device that uses pendulums to draw trajectories on a piece of paper. The output of such a harmonograph can be described mathematically and we can simulate a random harmonograph by drawing random numbers and following a trajectory defined by sine waves. I followed the blog post mentioned above which draws 12 random numbers and plots the trajectory defined by\n\n$$ x(t)=e^{-d_1t}\\sin(tf_1+p_1)+e^{-d_2t}\\sin(tf_2+p_2)$$\n$$y(t)=e^{-d_3t}\\sin(tf_3+p_3)+e^{-d_4t}\\sin(tf_4+p_4)$$\nwhere $t$ runs from $0$ to $1$.\nIn his post, the author implemented the harmonograph in R, but since my plotter works from Python, I ported his code to Python.\n\n```python\nimport numpy as np\n\n# draw the necessary random numbers\nf1, f2, f3, f4 = np.random.randint(2, 4, size=4) + (np.random.random(size=4)-0.5) / 10\nd1, d2, d3, d4 = np.random.uniform(0, 1e-02, 4)\np1, p2, p3, p4 = np.random.uniform(0, np.pi, 4)\n\n# define the space and follow the trajectory\nt = np.linspace(1, 100, num = 10**4)\nxs = xt(t)\nys = yt(t)\n```\nAfter this, I could plot the curve by defining lines between subsequent points and sending the instructions to my plotter. Using the classes and functions I defined before, this was very easy:\n\n```python\nobjs = [shapes.Point(xs[0], ys[0])] +\\\n  [shapes.Line(\n      shapes.Point(xs[i], ys[i]),\n      shapes.Point(xs[i+1], ys[i+1])\n   ) for i in range(len(xs)-1)]\n\ns = wake_up_serial('/dev/tty.wchusbserial1410', 115200)\nobjs_to_plotter(objs, s)\n```\n\nNote that I started with a `Point` because the pen needs to move to the initial position before it can start drawing. If you look carefully, you can see that the figure was built up using small line segments. Increasing the number of steps in the `np.linspace` command above will make the result smoother. Nevertheless, I think the result looks very nice!\n\n![Harmonograph, pen on paper](/post/2018-06-28-pen-plotter/harmonograph.jpg){width=600px}\n\n# Conclusion\n\nAll in all, it was a nice journey. I never considered myself an artist, but now I kind of know what it feels like to be one, even though I did not design anything by hand.\nSomeday, I want to learn [Processing](https://processing.org/), a programming language designed specifically for creating computer generated art.\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":true,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"markdown"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["../../styles.css"],"toc":true,"html-math-method":"katex","output-file":"index.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.7.33","theme":{"light":["cosmo"],"dark":["solar"]},"respect-user-color-scheme":true,"title":"Pen plotter","author":"Bas","date":"2018-06-28"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}